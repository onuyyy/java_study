package com.sist.exception;
/*
 * final 클래스 => 종단클래스
 * 				확장을 할 수 없다 (있는 그대로 사용) ex) String, Math, ...
 * 		- 상위클래스가 될 수 없다
 * 
 * 오버라이딩 (상속의 기본) => 변경해서 사용 (다형성)
 * 
 * 객체지향의 3대 요소
 * 1) 데이터 보호 목적 => 캡슐화 : 변수를 은닉화 => 메소드를 통해서 접근이 가능하게끔 한다
 * 							 ----------				  -------------
 * 							  private					  public
 * 							=> 변수는 2가지 기능만 수행
 * 								메모리 저장 / 메모리에서 데이터 읽기
 * 								setter			getter
 * 							=> 모든 멤버변수 : private
 * 							=> 모든 메소드(생성자) : public => 다른 클래스와 연결이 가능하게끔 만든다
 * 			접근지정어
 * 			- private : 자신의 클래스에서만 사용할 수 있다
 * 			- default : 같은 패키지에서만 접근이 가능
 * 			- public : 패키지 상관없이 모든 클래스에서 접근이 가능하다 (공개)
 * 2) 재사용하는 목적 : 상속, 포함 => 클래스 크기 결정 : 형변환
 * 	class A
 * 	class B extends A => A가 가지고 있는 모든 내용을 가지고 온다
 * 					  => A의 내용을 변경해서 사용, 추가가 가능하다
 * 						 라이브러리 => 프로그램에 맞지 않는 경우 : 수정
 * 			* A 상속을 내린 클래스가 B 상속을 받은 클래스보다 크다
 * 
 * A a = new A();
 * B b = new B();
 * A c = new B();	: 묵시적 형변환 (자동)
 * 			==> 추상클래스 / 인터페이스 => 얘네들은 메모리 할당인 안 된다
 * 				------------------ (미완성클래스) 메모리 할당시에 상속을 받은 클래스를 이용해서 메모리 할당을 한다
 * 									--------- 메소드가 구현이 안 된 상태
 * 									=> 설계, 같은 기능 => 처리를 프로그램에 맞게 할 때 
 * B d = (B)c;		: 명시적 형변환 (강제)
 * 								==> 라이브러리에서 많이 사용
 * 								==> 클래스를 저장해서 관리 (class) => collection
 * class A {		  => 포함 클래스
 * 	B b = new B();	  => 특별한 경우가 아니면 재정의하지 않는다, 있는 그대로 가져다 쓰려는 목적
 * }
 * 
 * 3) 수정, 추가 목적
 *  수정 (오버라이딩)
 *  추가 (오버로딩)
 * 			
 * 					오버로딩					오버라이딩
 * 관계 	  :        1개의 클래스				 상속관계
 * 					상속관계
 * 메소드명 :      	 동일						  동일
 * 매개변수 :	  	개수 또는 데이터형이				  동일
 * 					 다르다
 * 리턴형	  :			관계없음					 확장가능
 * 접근지정어 : 		관계없음					 확장가능
 * 사용처	  :		 	 생성자				인터페이스/추상클래스
 * 
 * ** 상속
 * 	1) 호출 => 상위클래스의 생성자가 먼저 호출된다 (기본생성자)
 * 	2) 예외 조건 : static, 생성자, 초기화블록, private
 * 
 * 
 * class A 
 * class B extends A
 * class D extends B
 * class E extends B
 * 
 * A a = new B();
 * A a = new A();
 * B b = new B();
 * B b = new D();
 * B b = new E();
 * ------------------ 가능
 * 
 * B b = (B)new A(); >> X
 * 
 * A a = new B();
 * B b = (B)a;		> 이렇게 형변환해야 함
 * 
 * 
 * 
 * 클래스의 종류
 * = 추상클래스
 * = 인터페이스 => 추상클래스의 단점을 보완 (클래스와 동일하게 취급)
 * 			 => 설계도 (구현이 안된 상태) : 미완성클래스 => 자신이 메모리 할당을 할 수 없다
 * 			 => 여러 개의 관련된 클래스를 모아서 한 개의 객체명으로 제어

 * 
 * 					추상클래스					인터페이스
 * 상속 관계			단일 상속					다중 상속
 * 상속 키워드			extends				   implements
 * 멤버 변수		   인스턴스변수				  상수형 변수만 가능
 * 					 정적변수
 * 메소드			   구현된 메소드			  구현이 안된 메소드			
 * 				 구현이 안된 메소드	
 * 기법				오버라이딩					오버라이딩
 * 형식		추상클래스		
 * 			[접근지정어] abstract class className {
 * 							변수 : 인스턴스변수, 정적변수 = 일반클래스와 동일
 * 							메소드 : 구현된 메소드(접근지정어 리턴형 메소드명 매개변수),
 * 								   구현이 안된 메소드(선언만) (접근지정어 abstract 리턴형 메소드명 매개변수)
 * 							생성자 : 오버로딩이 가능
 * 			}		
 * 			인터페이스
 * 			[접근지정어] interface interfaceName {
 * 							변수 선언 ==> 상수형 변수만 가능
 * 								int a = 10; ==> 값을 명시적으로 지정
 * 								public static final int a = 10;
 * 								------------------- 자동 추가되는 부분
 * 							구현이 안된 메소드 목록
 * 								void display();
 * 									=> public abstract void display();
 * 									   --------------- 자동 추가되는 부분
 * 							구현이 된 메소드
 * 								default void aaa() {}	==> 일반 메소드
 * 								static void bbb() {}	==> 정적 메소드
 * 			}
 * 
 * 					==> 인터페이스는 변수나 메소드가 public = 연결 목적이기 때문에, 언제든 연결이 가능해야 함
 * 
 * 상속 extends
 * interface ==> interface
 * 				implements
 * interface ==> class
 * 
 * 다중 상속
 * class A implements 인터페이스,인터페이스
 * 		
 * 
 * 
 * 
 */


import java.util.*;

abstract class c {
	c(){}
	c(int a) {}
}




class A {
	int a = 10;
	String name = "홍길동";

}

class B extends A {
	int b =20;
}

public class 정리_7장 {

	public static void main(String[] args) {
		
		B b = new B();
		System.out.println(b.a);
		
	}

}
