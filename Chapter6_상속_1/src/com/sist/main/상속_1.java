package com.sist.main;
/*
 * 
 * 1) 네트워크 프로그램
 * 2) 데이터베이스 프로그램
 * ------------------------------------
 * 데이터베이스는 데이터 저장 장소
 * ------------------------------------
 * 1. 메모리에 저장 : 변수 => 제어 (제어문, 연산자)
 * 2. 데이터가 많은 경우
 * 		= 같은 데이터형 : 배열
 * 		= 다른 데이터형 : 클래스
 * 3. 클래스
 * 		= 클래스 정의 방법 (객체지향프로그램 => 한 개의 클래스로 만드는 것이 아니라 클래스와 클래스의 연관 관계 => Spring
 * 										행위자(사용나, 관리자)
 * 		** 접근지정어 (권한)
 * 		private : 자신의 클래스에서만 사용이 가능 : 은닉화 (캡슐화)
 * 					=> 목적 : 데이터 보호
 *  				=> 변수 (클래스의 속성)
 *  	default : 같은 패키지 안에서만 사용이 가능
 *  				=> 윈도우, Thread (프로그램 안에서 여러개 프로그램을 수행)
 *  	protected : 같은 패키지 안에서만 사용이 가능
 *  				= 상속을 받는 경우 => 다른 패키지에서 접근이 가능
 *  				사용빈도가 거의 X, 상속을 내리면 모든 변수, 메소드 사용이 가능하다
 *  				private 변수는 접근이 불가하다
 *  -------------------------------------
 *  public : 모든 클래스에서 접근이 가능
 *  클래스 : 연관관계 => 다른 클래스에서 접근이 가능
 *  생성자 : 다른 클래스에서 메모리 할당 후 사용
 *  메소드 : 다른 클래스와 통신을 담당
 *  
 *  크기 순서
 *  private < default < protected < public
 *  
 *  오버라이딩 : 접근지정어의 확장은 가능 (축소는 불가능) 
 *  --------------------------------------
 *  
 *  상속 : 반복 제거 
 *  class A {
 *  	int a,b,c,d,e;}
 *  }
 *  class B estends A
 *  }
 *  int a,b,c,d,e;
 * ----------------------------------------
 * 메소드 구성 요소 : 벤치마킹 ==> 요구사항 분석
 * 
 * class ClassName {
 * 		속성, 필드 => 멤버변수 (캡슐화)	=> 다른 클래스에서 사용이 가능하게 만든다
 * 		 			------------- 읽기/쓰기 메소드 : getter setter => 인스턴스 메소드
 * 		공유변수 (static) : 패턴 (싱글턴) => 한 개의 객체만 사용
 * 				------ 메모리 공간이 한 개
 * 				 	   공유하는 데이터가 존재
 * -----------------------------------------
 * 생성자
 * 	1. 클래스명과 동일
 *	2. 멤버변수에 대한 초기화
 *	3. 생성자가 없는 경우에는 자동으로 컴파일러가 기본생성자를 추가해준다
 *									   -------- 매개변수가 없는 생성자
 *		ex) class A {
 *			}
 *			class A {
 *				A() {}
 *			}			>> 위의 A와 아래의 A는 같은 클래스, 위의 A() 생성자는 생략되어있는 것임
 *	4. 모든 클래스는 생성자는 1개 이상은 가지고 있다
 *	5. 생성자는 객체를 생성할 때 호출되는 메소드이다
 *	6. 리턴형은 존재하지 않는다
 *	7. 생성자는 필요시에는 여러 개를 만들 수 있다
 * --------------------------------------------
 * 	= 오버로딩을 지원한다 (중복메소드)
 * 		한 개의 메소드 이름으로 여러 개 기능을 생성
 * 			오버로딩 (new) / 오버라이딩 (modify)	
 * 
 * 		조건 :
 * 		- 메소드명이 동일
 * 		- 한 개의 클래스에서 만든다
 * 		- 매개변수의 개수나 데이터형이 달라야 한다
 * 		- 리턴형은 관계가 없다
 * 
 * 			ex) class A {	
 * 					A() {}					>> 매개변수 없는 것을 기본생성자, 아래 3개는 그냥 생성자
 * 					A(int a){}
 * 					A(double d) {}
 * 					A(int a, int b) {}
 * 				}
 * 
 *  			ex) class A {
 * 						A(int a){}
 * 						A(double d) {}
 * 						A(int a, int b) {}		>> 3개 다 생성자이기때문에 기본생성자 못 씀
 * 					}
 * 					A a = new A();		>> 오류 발생
 * 			
 * 			** 생성자는 초기화를 담당, 시작과 동시에 처리하는 일이 있는 경우
 * 				윈도우 디자인, 웹 메인, 자동 로그인, 오라클 연결, ...
 * 					=> 가장 먼저 호출되는 메소드가 생성자
 * 			** new (객체 생성 방법)
 * 				class A
 * 				1) A a = new A();
 * 				-------------------
 * 				2) A a = Class.forName("A").newInstance()
 * 				3) A a = A.newInstance()
 * 				------------------------------------------ 2,3 리플렉션
 * 			메소드 : 기능을 수행, 다른 클래스와 연결할 때 사용 
 * 			메소드 제작방법 (형식)
 * 			[접근지정어][제어어] 리턴형 메소드명(매개변수) {	 > 선언부
 * 				구현부
 * 			}
 *				1. 선언부 		
 *					= 접근지정어 : public, default
 *					= 제어어 : static, final, abstract
 *						static : public static
 *									=> 객체마다 공통으로 사용되는 기능 (데이터베이스 연결)
 *						final : public final : 오버라이딩 안 된다 (수정 X) ex) Math, String, System => 모든 메소드를 그대로 써야 함
 *									=> 종단메소드, 종단클래스
 *						abstract : 선언만 하는 메소드 ==> 구현 (프로그램에 맞게 구현해서 사용) 
 *									=> 추상클래스, 인터페이스 (**스프링의 기반) : 결합성이 낮은 프로그램 // 독립적인 프로그램이다
 *		 							ex) 버튼 클릭
 *				리턴형 : 사용자 요청 처리한 결과값
 *						한 개만 사용이 가능
 *							=> 여러 개의 값이 있는 경우
 *								- 같은 데이터형이 여러 개일 경우 => 배열 => 컬렉션
 *													배열(고정적), 컬렉션(가변형)
 *								- 다른 데이터형이 여러 개일 경우 => 클래스
 *													member, movie, string, ...
 *							=> 한 개의 결과 값 : 기본형, String
 *							=> 결과값이 없는 경우 : 메소드 자체에서 처리 (void)
 *				매개변수 : 여러 개 사용이 가능하다, 사용자가 요청하는 값
 *						- 매개변수는 최소화를 시킨다
 *						  ------ 3개 이상이면 배열 아니면 클래스를 이용한다
 *
 *				2. 구현부
 *					변수가 선언이 되면 => 지역변수 (메소드 종료와 동시에 사라진다)
 *					지역변수 : 초기화가 안 되어있다 (반드시 초기화 후 사용해야 한다)
 *
 *	-------------------------------------------------------------------
 *	this : 클래스마다 this를 가지고 있다 (static)
 *			자신의 객체 주소를 가지고 있다
 *			멤버변수와 지역변수를 구분할 때
 *
 *			class A {
 *				int age;
 *				public void setAge(int age) {
 *					age = age;					//	지역변수 우선순위 (매개변수 포함)
 *					---   --- > 매개변수 (age)
 *					 ㅣ
 *				   멤버변수 (this.age)
 *				}
 *			}
 *
 *
 *	class A 
 *	A a = new A();
 *		=> JVM : this = a;
 *
 *	class A {
 *		A() {					>> this 존재
 *		}
 *		void display() {		>> this 존재
 *		}
 *		static void aaa() {		>> this 존재 X , static은 공유하기 것이기 때문에 A a = new A(); 로 객체 생성한 후에 사용해야 함
 *		}
 *	}
 *		
 *		** 멤버변수, 멤버베소드, 생성자 ==> 클래스 소속
 * }
 * 
 * ========================================================================
 * 
 * ** 6장 시작
 * 	= 재사용 기법
 *  = 수정, 추가
 *  = 클래스 종류
 *  ---------------
 *  견고한 프로그램을 만든다
 *   - 재사용 / 가독성	/ 견고성 
 *   
 *   자바 상속의 특징
 *   	= 재사용 목적으로 사용한다 (기존의 만들어진 클래스를 확장해서 사용)
 *   	** 필요시에 변경해서 사용이 가능하다 (오버라이딩)
 *   	= 반복 코딩을 제거할 수 있다
 *   		class A {
 *   			int a,b,c,d,e;
 *   			void display() {}
 *   			--
 *   			--
 *   		}
 *   		class B extends A {			>> A에 있는 내용을 그대로 가져온다 extends A
 *   			void display() {}		>> 필요한 것만 고칠 수 있음, 나머지는 그대로 사용함
 *   		}
 *   
 *   				** 상속 : 기존에 만들어진 클래스를 확장해서 새로운 클래스르 만들어서 사용
 *   					ex) class Board {
 *   							글쓰기
 *   							목록보기
 *   							상세보기
 *   							검색
 *   						}
 * 							
 * 								확장 => 기존의 기능 사용, 변경, 추가 : 오버라이딩
 * 							class 갤러리게시판 extends 게시판 {
 * 								글쓰기   =>   이미지 업로드 추가로 필요 
 * 								목록보기	=>	이미지 출력
 * 								상세보기
 * 								검색
 * 							}
 * 		= 유지보수용 (SM)
 * 		= 단일 상속만 가능하다
 * 			class A
 * 			class B extends A
 * 			class C extends B
 * 		= 상속을 내리는 클래스 : 부모클래스, 슈퍼클래스, 베이스클래스, 상위클래스
 * 		= 상속을 받는 클래스 : 자식클래스, 서브클래스, 파생클래스, 하위클래스
 * 		= 상속이 있는 경우에는 클래스의 크기가 있다 (형변환)
 * 		= 상속을 내리는 클래스 > 상속을 받는 클래스보다 크다
 * 	
 * 		class Super
 * 		class Sub extends Super
 * 
 * 		Sub sub = new Sub();		// 확장된 클래스 자체 생성
 * 		Super super = new Sub();	// 하위 클래스를 이용하여 상위 클래스를 만들 수 있다
 * 		-------------------------------	인터페이스 / 추상클래스
 * 										------------------- 미완성된 클래스
 * 		Sub sub1 = (Sub)super;		// 형변환 후 사용 가능
 * 		-------------------------------
 * 
 * 		일반적으로 클래스와 생성자가 동일
 * 		-------------------------------
 * 			=> 클래스와 생성자가 다를 경우
 * 			=> 클래스와 메소드 이용
 * 		------------------------------- 인터페이스
 * 
 * 		List list = new ArrayList();
 * 		Map map = new HashMap();
 * 		Connection conn = getConnection();		인터페이스는 new를 사용하지 못함, 앞에와 뒤에가 다르면 인터페이스구나라고 생각하면 됨
 * 
 * 		List list = new List(); > 오류
 * 
 * 		==> class A {
 * 				int a,b;
 * 				void display() {1}
 * 			}
 * 
 * 			class B extends A {
 * 				// int a,b;				>> 숨겨져 있음
 * 				int c;
 * 				void display() {2}		>> 오버라이딩
 * 			}
 * 
 * 			A aa = new A();			>> c는 못 씀 
 * 			aa.a
 * 			aa.b
 * 			aa.display()		=> 1
 * 			
 * 			B bb = new B();
 * 			bb.a
 * 			bb.b
 * 			bb.c
 * 			bb.display();		=> 2
 * 
 * 			A aaa = new B();				// 변수는 A가 가지고 있는 변수만 사용이 가능, 생성자는 메소드를 제어한다, 메소드는 new B / 변수는 A aaa 따라감
 * 			aaa.a
 * 			aaa.b
 * 		//	aaa.c				>> 사용 불가
 * 			aaa.display();		=> 2
 * 
 */

class Data {
	private int a;

	public int getA() {
		return a;
	}

	public void setA(int a) {
		this.a = a;
	}
	
}

class Human {
	Data d = new Data();		//	>> 공통으로 쓸 수 있게 
	
	public void getData(int a) {
		d.setA(a);
	}
	public void print() {

		System.out.println("d.a="+d.getA());
	}
}



	// 상속

class Super {
	
	int a = 10;
	int b = 20;
	public void display() {
		System.out.println("Super가 가지고 있는 display");
		
	}

}

class Sub extends Super {		// Super로부터 상속을 받음
	
	// Super의 데이터가 그대로 와있는 상태
	
	
}
// Super로부터 상속을 받는다 => 예외조건) 생성자, 초기화 블록, static(공유)
// private => 상속은 가능, 접근이 불가능
//		   => 상속을 내릴 땐 protected가 더 편리
//		   => getter / setter
public class 상속_1 {

	public static void main(String[] args) {
		
//		Human h = new Human();
//		h.getData(50);
//		h.print();
//		
//		Human h1 = new Human();
//		h1.getData(100);
//		h1.print();
		
		
		Sub sub = new Sub();
		System.out.println(sub.a);//10
		System.out.println(sub.b);//20
		sub.display();
		
		
		

	}

}
