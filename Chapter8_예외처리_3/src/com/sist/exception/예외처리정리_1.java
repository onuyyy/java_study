package com.sist.exception;
/*
 * 
 * 1. 예외처리 방법과 형식
 * 		1) 직접처리(예외복구) : 프로그래머
 * 			try {
 * 				실행 가능한 소스 코딩 (정상수행)
 * 			} catch(예외처리 종류) {
 * 				try에 있는 소스를 실행하는 과정에서 오류가 발생했을 때 처리하는 영역
 * 			} finally {
 * 				생략이 가능, 무조건 수행하는 문장
 * 					=> ex) 서버 닫기, 오라클 닫기, 파일 닫기, ...
 * 			}
 * 			
 * 			catch는 오류 발생 예외를 복구해주는 영역이기 때문에,
 * 											다중으로 사용이 가능하다 (catch절이 많을 수 있음)
 * 											=> 한 개의 예외처리를 통합할 수 있다
 * 											=> Exception / Throwable
 * 			- catch절은 순서가 존재한다 >> 상위 클래스는 아래에 배치한다
 * 			- try절이 정상 수행을 하면 catch절은 수행하지 않는다
 * 			- catch절에 오류가 나면 오류가 난 줄부터는 수행을 하지 않는다
 * 					=> catch를 수행하여 에러 복구 후 종료한다
 * 				try {
 * 					---
 * 					---			>> 에러 발생시 여기서부터 수행 x -> catch로 넘어감
 * 					---
 * 				} catch () {
 * 				}				>> catch는 위에서부터 한 개씩 검색한 후에 해당 예외처리클래스를 찾아 준다	(다중조건문과 비슷하다)
 * 								>> catch는 한 개만 수행
 * 
 * 		2) 간접처리(예외회피) : 자바, 오픈 라이브러리
 * 			예외에 대하여 예측되는 예외클래스를 선언만 한다
 * 				=> 다른 메소드를 호출할 때 처리 후 사용이 가능하다 (try ~ catch이 더 편함)
 *				=> 예외클래스의 순서가 존재하지 않는다
 *				=> UnCheckException은 사용하지 않고 보통 CheckException을 사용한다
 *				=> 라이브러리
 *					java.lang / java.util 			==> 보통 UnCheckException
 *													==> 예외처리를 반드시 해야하는 것은 아니다
 *					java.io / java.net / java.sql 	==> CheckException
 *													==> 예외처리를 반드시 해야한다
 *				=> 형식)
 *					[접근지정어] 리턴타입 메소드명() throws 예외처리클래스, ... (예외처리클래스는 여러 개일 수 있음)
 *					=> 처리
 *						------------------
 *						메소드() throws {
 *							메소드호출
 *						}
 *						------------------
 *						메소드() {
 *							try {
 *								메소드 호출
 *							} catch (예외처리클래스) {
 *								}
 *						}
 *						------------------	>> 권장사항
 *
 * 
 * 		3) 임의발생		 
 * 			테스트용으로 보통 사용한다
 * 			throw new 예외처리클래스(); => 해당 예외처리클래스가 있는 catch로 이동한다
 * 
 * 		4) 사용자정의
 * 			예외처리 클래스를 상속 받아서 처리한다
 * 				class MyException extends Exception () {
 * 				}				
 * 					==> if ~ else 로 처리되면 if문을 먼저 사용한다
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
public class 예외처리정리_1 {

	public static void main(String[] args) {
		
		

	}

}
