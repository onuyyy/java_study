import java.util.Arrays;

/*
 * 
 * 	모아서 관리한다
 * 		> 데이터 : 배열 / 클래스
 * 		> 명령문 : 메소드 (재사용)
 * 
 * 1. 같은 데이터형을 모아서 관리
 * 		= 연속적으로 메모리 배치
 * 		= 인덱스 번호를 이용한다 (0번부터 시작한다)
 * 		= 고정적이다 (변경시에는 더 큰 배열을 생성해서 사용한다) - 단점
 * 		= 배열 복사
 * 			1) 얕은 복사 : 참조 또는 별칭이라고 한다 ( 같은 메모리 주소를 활용하는 것)
 * 					int[] arr = {};
 * 					int[] arr2 = arr;	> 같은 메모리를 사용하기 때문에 같이 바뀌니 주의해야 한다
 * 			2) 깊은 복사 : 데이터만 복사하고, 새로운 메모리를 만들어서 처리한다
 * 					int[] arr = {};
 * 					int[] arr2 = arr.clone();
 * 					System.arraycopy();
 * 		= 배열의 크기 : length
 * 		= 출력시에는 주로 for - each 사용 (향상된 for)
 * 			> 브라우저에서는 변경하는 것이 아니라, 있는 그대로 출력한다
 * 			> 배열이나 컬렉션 (데이터가 모아져있을 때) 사용한다
 * 				> 인덱스를 이용하는 프로그램이 아니라 배열에 저장된 값을 한개씩 읽어 온다
 * 				int[] arr = {10, 20, 30, 40, 50};	>> 여기 데이터형이 int 밑으로 내려간다 또는 더 큰 데이터형이 가야 한다
 * 					for(int a:arr) {
 * 					a=10, a=20, a=30, a=40, a=50 
 * 					}
 * 			ex	===============================
 * 				char[] arr = {'A','B','C'}
 * 				for(char a:arr) {	
 * 					// char c는 실제 저장된 데이터를 갖고 오는 것이다
 * 				}
 * 			ex	===============================
 * 				int[] arr = {10, 20, 30, 40, 50};
 * 				for(int i:arr) {
 * 					i = 100;
 * 				}

						>> 인덱스번호를 가져와야 값 바꿀 수 있음	ex) arr[1] 이걸 바꿔야 함 이게 변수명임
							int i = 10;	
							int b = 1;
							b = 100;		>> 원 배열에 값이 바뀌진 않는다

 * 		= 초기값, 값을 변경시에는 일반 for문 사용해야 함 (for - each 사용 불가) 
 * 			> 인덱스가 있어야 변경할 수 있음
 * 	
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
public class 배열_1 {

	public static void main(String[] args) {
		
		int[] arr = {10, 20, 30, 40, 50};
		for(int i:arr) {
			i = 100;
			System.out.print(i+"\t");
		}
		System.out.println(Arrays.toString(arr));

		
		
	}

}
