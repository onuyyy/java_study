package com.sist.main;
/*
 * 
 * 클래스
 * 1. 구성요소
 * 		1) 변수
 * 			- 인스턴스변수 : 객체마다 메모리를 따로 저장하는 과정
 * 							=> new를 이용해서 메모리 저장공간이 만들어진 경우
 * 				A a = new A()
 * 					- 인스턴스(객체)
 * 						a.변수명
 * 			- 정적변수 : 메모리 공간이 한 개 (공유변수, 믈래스변수)
 * 				static => 컴파일시 자동으로 생성이 된다
 * 			- 지역변수 : 기능 처리에 필요한 데이터를 설정 (메소드 종료와 동시에 사라진다)
 * 			- 매개변수 : 사용자 요청값 = > 메소드 종료와 동시에 사라진다
 * 						*** 변수는 반드시 초기화 후에 사용한다
 * 							== 자동 초기화 : 클래스 영역에 선언된 변수
 * 											인스턴스, 정적변수는 초기화가 된다
 * 							=> 초기화가 없는 경우 : 지역변수, 매개변수
 * 
 * 					class A {
 * 						String addr;		>> Address와 map이 addr을 쓰기 때문에 addr 전역변수의 선언이 필요하다
 * 						void Address(String addr) {
 * 							this.addr = addr
 * 						}
 * 						void map() {
 * 							addr
 * 						}
 * 						void 근처맛집() {
 * 							addr			>> 메소드에서 같은 변수를 쓰고 있는지를 잘 봐야 한다 / 같이 쓰고 있으면 : 전역벽수
 * 						}
 * 					}
 * 	
 * 
 * 				* 메모리구조
 * 				MethodArea, static	=>	컴파일러가 자동으로 저장해줌
 * 				Method도 메모리에 저장됨 
 * 					void method() {}; > 메소드는 구현이 되어야 저장이 된다
 * 										선언만 하면 저장 안 됨 => 미완성된 클래스
 * 										--------> 추상클래스, 인터페이스 : 요구사항 분석할 때 많이 사용
 * 														   --------> 데이터베이스 연결, 윈도우, 네트워크 서버, 웹 구현 등에 사용
 * 												  --------> void method(); : 사용자마자 다르기 때문에 선언만 한다
 * 				Stack : LIFO
 * 						지역변수, 매개변수 저장 => 메모리 자체에서 관리를 해줌
 * 										  => 블록이 종료되면 사라진다
 * 						class A {
 * 							void method() {
 * 								int a = 10;
 * 								if(a%2==0) {
 * 									int b = 20;
 * 									if(b==20) {
 * 										int c = 30;
 * 									}	//	c
 * 								}	// b
 * 							}	// a
 * 						} 								>> 나중에 들어온 거 먼저 나간다
 * 				Heap : 동적 메모리 할당	=> 객체변수, 배열 (참조변수) 들이 저장
 * 						=> 관리는 프로그래머가 한다 => 관리를 못하면  GC (자동메모리 회수)
 * 						=> 객체 = null 주면 DB 없어진다
 * 					class A {	>>	 인터프리터 : 한 줄씩 번역하는 것
 * 						---
 * 						---	new (한 줄씩 있다가 new가 나오면 메모리 할당을 한다)
 * 						---
 * 					}
 * 				변수 => Stack에 저장
 * 					int a = 10;
 * 				0 ------
 * 					사용중
 * 				4 ------
 * 					사용중
 * 				8 ------
 * 					> 값 들어감 => 10;		==> 값이 어디에 있는지 몰라서 메모리 주소에 대한 별칭을 준다, 이것이 'a' 변수!!
 * 				12 -----
 * 				
 * 				배열
 * 					-------------------------
 * 					ㅣ		ㅣ		ㅣ		ㅣ
 * 					-------------------------
 * 
 * 				클래스		>> 다른 데이터형 모은다
 * 					-------------------------
 * 				
 * 					    ------------------
 * 								10
 * 					    ------------------
 * 							  "홍길동"
 * 					    ------------------
 * 							   "남자"
 * 					    ------------------
 * 					-------------------------
 * 
 * 
 * 		2) 메소드	: 명령문의 집합 => 단락 (구조적인 프로그램)
 * 				  반복 수행 (반복제거) : 재사용의 목적, 한 가지 기능을 수행
 * 				  다른 통신 담당
 * 								
 * 			1. 종류
 * 				인스턴스 메소드 : 따로 작동하는 메소드
 * 					Srring s = "Hello Java";
 * 					s.substring()					
 * 
 * 					String s1 = "Hello Oracle";
 * 					s1.substring()
 * 
 * 				정적 메소드 : 동시에 작동 (static) => 자동 저장
 * 					10 => "10" ,  true => "true"
 * 					String.vaulOf(데이터형)
 * 					Math.random()
 * 
 * 				추상 메소드 : 설계 => 모든 개발자가 같은 메소드를 제어
 * 							   => 표준화 작업
 * 							   => 여러 개의 클래스르 묶어서 한 개의 이름으로 처리할 수 있다
 * 				종단 메소드 : final void aaa();
 * 							=> 변경할 수 없다 (확장불가) 오버라이딩, 오버로딩 x
 * 
 * 
 * 		3) 생성자 : 객체 생성시 호출되는 메소드
 * 				  멤버변수의 초기화
 * 				  클래스명과 동일
 * 				  리턴형이 없다
 * 				  생성자는 여러 개 존재할 수 있다 = 오버로딩
 * 				  클래스 안에 생성자를 반드시 구현하는 것은 아니다	
 * 						=> 기본 생성자를 추가한다 : 매개변수가 없는 생성자
 * 
 * 			- 변수만 모아서 관리 : 사용자 정의 데이터형 => ~VO, ~DTO, ~Bean : 변수만 갖고 있음
 * 								getter/setter 는 메소드 : 읽기와 쓰기만 가능한 변수
 * 			- 메소드만 모아서 관리 : 액션클래스 
 * 								=>  ~System, ~DAO, ~Manager, ~Service, ...	: 기능만 갖고 있음
 * 			- 변수 + 메소드 모아서 관리 : 조립
 * 								=> ~Model, ~Controller, ~Action
 * 
 * 
 * 
 * ===================================================================================
 * 2. 클래스 설계
 * 		1) 기능 설계 : 메소드 추출
 * 		2) 기능에서 사용하는 변수 추출
 * 		3) 클래스 설계
 * 			class ClassName {
 * 				변수
 * 				메소드
 * 				생성자
 * 			}
 * 		4) 메모리 저장
 * 			ClassName c = new ClassName()
 * 		5) 활용
 * 			c.메소드 ...
 * 		6)소멸
 * 			c = null
 * 
 * 
 * ===================================================================================
 * 3. 접근지정어
 * ----------------------------------------------------------------------
 * private : 자신의 클래스에서만 접근이 가능 => 데이터 보호 (캡슐화)
 * ----------------------------------------------------------------------
 * default : 같은 패키지 안에서만 접근이 가능
 * ----------------------------------------------------------------------
 * protected : 같은 패키지 안에서만 접근이 가능, 상속이 있는 경우 다른 패지키에 접근이 가능
 * ----------------------------------------------------------------------
 * public : 패키지 상관없이 모든 클래스에 접근이 가능
 * ---------------------------------------------------------------------
 * 멤버변수 [접근지정어] 데이터형 변수명
 * 메소드	  [접근지정어] [제어어] 리턴형 메소드명(매개변수) {}
 *		제어어 : static 
 *	** 
 * 변수 : private
 * 메솓 : public
 * 생성자 : public
 *
 * 
 * ===================================================================================
 * 4. 객체지향의 특성
 * 		1) 캡슐화 => 데이터를 은닉화한 후에 메소드를 통해서 접근 가능
 * 				   ----------- private => getter/setter
 * 		2) 재사용 기법
 * 			=> 상속 (is-a) : 기존의 기능을 변경해서 사용
 * 			=> 포함 (has-a) : 기존의 기능을 있는 그대로 사용
 * 		3) 수정, 추가 => 다형성
 * 		   	   ----> 오버로딩
 * 		   ---> 오버라이딩
 * 
 * 			---------------------------------------------------
 * 			메소드명이 동일
 * 			---------------------------------------------------
 * 			상속관계				1개 클래스 / 상속 관계
 * 			---------------------------------------------------
 * 			매개변수	동일			매개변수의 개수 / 데이터형
 * 			---------------------------------------------------
 * 			리턴형	동일			리턴형은 관계 없다
 * 			---------------------------------------------------
 * 			접근지정어 확장			
 * 					가능 수정		새로운 기능 추가
 * 			---------------------------------------------------
 * 
 * 
 * 			** 상속 클래스 (is-a)
 * 			class A {
 * 			}
 * 			class B extends A {
 * 			}
 * 
 * 			** 포함 클래스 (has-a)
 * 			class A {
 * 			}
 * 			class B {
 * 				A a;		>> 있는 그대로 가져다 씀 (변경, 추가 x)
 * 			}
 * 
 * 				 
 * ===================================================================================
 * 5. 제어자
 * 		static / abstract / final
 * 		=> static final : 상수
 * 		=> final : 상수형 변수		==> final만 메소드 안에서 사용이 가능
 * 			== 사용하는 위치 (오라클 주소, 계쩡명, 비밀번호) 고정!
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
public class 객체지향정리 {

	public static void main(String[] args) {


	}

}
